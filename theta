#!/usr/bin/env python3
"""
Paper Trading Bot (Weekly Theta Harvest) - UPDATED & CORRECTED
- Paper-only (no real order placement)
- Uses Dhan (dhanhq) if available for:
    - ATM strike selection (ATM_Strike_Selection)
    - Option Greeks (get_option_greek)
    - Option chain (option_chain) and quotes (get_quotes)
- Weekly schedule: Mon/Tue -> NIFTY, Wed/Thu -> SENSEX
- Entry window 09:45-10:15 | Partial exit around 14:00 | Full exit at 15:00
- Auto-shift straddle -> strangle if net delta one-sided (simulated)
- IV spike protection (paper alerts + pause)
- CSV trade log (paper_trades.csv)
"""

import time
import math
import csv
from datetime import datetime, time as dt_time, timedelta
import pandas as pd
from typing import Optional, Tuple

# ----------------------------- Dhan SDK (optional) -----------------------------
try:
    from dhanhq import dhanhq
    DHAN_AVAILABLE = True
except Exception:
    DHAN_AVAILABLE = False

# ----------------------------- CONFIG -----------------------------
ACCESS_TOKEN = "your_access_token_here"
CLIENT_ID = "your_client_id_here"

if DHAN_AVAILABLE and ACCESS_TOKEN and CLIENT_ID:
    dhan = dhanhq.Dhan(ACCESS_TOKEN, CLIENT_ID)
else:
    dhan = None

UNDERLYINGS = {
    "NIFTY": {"under_security_id": 13, "name": "NIFTY"},
    "SENSEX": {"under_security_id": 4, "name": "SENSEX"}  # update IDs if needed
}
WEEK_RULES = {0: "NIFTY", 1: "NIFTY", 2: "SENSEX", 3: "SENSEX", 4: None, 5: None, 6: None}

ENTRY_WINDOW_START = dt_time(9, 45)
ENTRY_WINDOW_END = dt_time(10, 15)
PARTIAL_EXIT_TIME = dt_time(14, 0)
FULL_EXIT_TIME = dt_time(15, 0)
NO_TRADE_START = dt_time(9, 15)
NO_TRADE_END = dt_time(9, 45)

LOT_SIZE = 25
STRIKE_STEP = 50

# thresholds
DELTA_SHIFT_THRESHOLD = 0.35
VIX_SPIKE_PCT_1 = 0.02
VIX_SPIKE_PCT_2 = 0.04
VIX_SPIKE_PCT_3 = 0.06

MAX_TRADES_PER_DAY = 2
DAILY_PROFIT_LIMIT = 5000.0
DAILY_LOSS_LIMIT = -5000.0

POLL_INTERVAL = 20  # seconds
TRADE_LOG_CSV = "paper_trades.csv"

# ----------------------------- PAPER STATE -----------------------------
state = {
    "paper_positions": [],   # list of dicts for each leg/trade
    "straddle": None,        # dict with call_row, put_row, strike, placed_at
    "initial_iv": None,
    "last_iv": None,
    "theta_alert_sent_today": False,
    "trades_today": 0,
    "daily_pl": 0.0,
    "trading_paused": False,
    "paused_reason": None,
    "last_reset_date": None
}

# ----------------------------- UTIL -----------------------------
def now_time():
    return datetime.now().time()

def today_weekday():
    return datetime.now().weekday()

def in_time_window(start: dt_time, end: dt_time, t: Optional[dt_time] = None):
    t = t or now_time()
    if start <= end:
        return start <= t <= end
    return t >= start or t <= end

def send_telegram(msg: str):
    # Placeholder: replace with your Telegram function if available
    print(f"[TG {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] {msg}")

# ----------------------------- SAFE FIELD ACCESS -----------------------------
def safe_get_field(row, keys):
    """
    Robustly extract a value from a row (dict or pandas Series) trying multiple keys.
    """
    if row is None:
        return None
    # dict-like
    if isinstance(row, dict):
        for k in keys:
            if k in row and row[k] not in (None, "", pd.NA):
                return row[k]
    # pandas series or object attribute
    try:
        for k in keys:
            if hasattr(row, k):
                v = getattr(row, k)
                if v not in (None, "", pd.NA):
                    return v
    except Exception:
        pass
    # series indexing
    try:
        for k in keys:
            if k in row and row[k] not in (None, "", pd.NA):
                return row[k]
    except Exception:
        pass
    # fallback: numeric values
    try:
        for v in row:
            if isinstance(v, (int, float)):
                return v
    except Exception:
        pass
    return None

# ----------------------------- DATA FETCHING -----------------------------
def fetch_option_chain(under_security_id) -> pd.DataFrame:
    """Return option chain DataFrame (defensive)."""
    if dhan is None:
        return pd.DataFrame()
    try:
        oc = dhan.option_chain(under_security_id=under_security_id, under_exchange_segment=dhanhq.NSE_FNO)
    except Exception as e:
        print("fetch_option_chain error:", e)
        return pd.DataFrame()
    # find likely payload key
    if isinstance(oc, dict):
        for k in ("data", "records", "result", "options"):
            if k in oc and isinstance(oc[k], (list, pd.DataFrame)):
                return pd.DataFrame(oc[k])
    if isinstance(oc, list):
        return pd.DataFrame(oc)
    try:
        return pd.DataFrame(oc)
    except Exception:
        return pd.DataFrame()

def get_quotes(under_security_id) -> dict:
    if dhan is None:
        return {}
    try:
        return dhan.get_quotes(underlying_id=under_security_id) or {}
    except Exception as e:
        print("get_quotes failed:", e)
        return {}

def atm_from_api(underlying_name: str) -> Optional[int]:
    """
    Use ATM_Strike_Selection if available, else fallback to quote-based rounding to STRIKE_STEP.
    """
    if dhan is not None:
        try:
            res = dhan.ATM_Strike_Selection(Underlying=underlying_name, Expiry=0)
            # expected to return (CE_symbol, PE_symbol, strike) or similar
            if isinstance(res, (list, tuple)) and len(res) >= 3:
                # support both (ce, pe, strike) or dict/list
                strike = res[2]
                try:
                    return int(round(float(strike) / STRIKE_STEP) * STRIKE_STEP)
                except Exception:
                    pass
    except Exception:
        pass
    # fallback: quote
    info = UNDERLYINGS.get(underlying_name)
    if not info:
        return None
    q = get_quotes(info["under_security_id"])
    ltp = safe_get_field(q, ["last_price", "ltp", "last", "lastPrice"])
    try:
        if ltp is None:
            return None
        ltp = float(ltp)
        return int(round(ltp / STRIKE_STEP) * STRIKE_STEP)
    except Exception:
        return None

def find_option_by_strike_and_type(df: pd.DataFrame, strike: float, otype: str):
    """
    Robust search for option row with strike and type (CE/PE).
    """
    if df is None or df.empty:
        return None
    strike_cols = [c for c in df.columns if "strike" in c.lower()]
    type_cols = [c for c in df.columns if ("option" in c.lower() or "opt" in c.lower() or c.lower() == "type")]
    id_cols = [c for c in df.columns if c.lower() in ("security_id", "id", "instrument_token", "instrumentid")]
    # try numeric strike columns
    for sc in strike_cols:
        try:
            mask = pd.to_numeric(df[sc], errors="coerce") == float(strike)
            if type_cols:
                mask = mask & df[type_cols[0]].astype(str).str.upper().str.contains(otype.upper(), na=False)
            res = df[mask]
            if not res.empty:
                return res.iloc[0]
        except Exception:
            continue
    # fallback: search text representation
    for idx, row in df.iterrows():
        txt = " ".join(map(str, row.values)).upper()
        if str(int(strike)) in txt and otype.upper() in txt:
            return row
    return None

# ----------------------------- PAPER ORDER SIM (NO LIVE ORDERS) -----------------------------
def paper_sell_option_leg(security_row, leg_type: str, qty: int = LOT_SIZE) -> dict:
    """Simulate selling an option leg at latest LTP from row."""
    now = datetime.now()
    price = safe_get_field(security_row, ["last_price", "ltp", "last", "close", "lastPrice", "lastTradedPrice"]) or 0.0
    try:
        price = float(price)
    except Exception:
        price = 0.0
    # determine security id value
    sec_id = safe_get_field(security_row, ["security_id", "id", "instrument_token", "instrumentId"]) or "UNKNOWN"
    strike_val = None
    try:
        # attempt to find strike column
        for c in (c for c in (security_row.index.tolist() if hasattr(security_row, "index") else []) if "strike" in c.lower()):
            strike_val = safe_get_field(security_row, [c])
            break
    except Exception:
        strike_val = None
    trade = {
        "id": f"PAPER-{leg_type}-{int(time.time()*1000)}",
        "leg": leg_type,
        "security": str(sec_id),
        "strike": strike_val,
        "entry_price": round(price, 2),
        "qty": int(qty),
        "side": "SELL",
        "timestamp": now.isoformat()
    }
    state["paper_positions"].append(trade)
    log_paper_trade(trade, action="ENTRY")
    print(f"[PAPER SELL] {leg_type} @ {price:.2f} qty={qty}")
    return trade

def paper_buy_to_close(security_row, leg_type: str, qty: int = LOT_SIZE) -> Optional[dict]:
    """Simulate buying back an existing short leg."""
    now = datetime.now()
    price = safe_get_field(security_row, ["last_price", "ltp", "last", "close", "lastPrice", "lastTradedPrice"]) or 0.0
    try:
        price = float(price)
    except Exception:
        price = 0.0
    closed = None
    # find matching open short
    for t in state["paper_positions"]:
        if t.get("leg") == leg_type and t.get("side") == "SELL" and not t.get("closed"):
            pnl = (t["entry_price"] - price) * t["qty"]
            t["closed"] = True
            t["exit_price"] = round(price, 2)
            t["exit_ts"] = now.isoformat()
            t["pnl"] = round(pnl, 2)
            state["daily_pl"] += pnl
            log_paper_trade(t, action="EXIT")
            closed = t
            print(f"[PAPER BUY-CLOSE] {leg_type} exit @{price:.2f} pnl={pnl:.2f}")
            break
    if closed is None:
        print("[PAPER BUY-CLOSE] No matching leg to close for", leg_type)
    return closed

def paper_place_short_straddle(under_security_id: int, strike: int) -> Tuple[Optional[dict], Optional[dict]]:
    """Simulate selling ATM CE and PE at current LTPs."""
    df = fetch_option_chain(under_security_id)
    ce = find_option_by_strike_and_type(df, strike, "CE")
    pe = find_option_by_strike_and_type(df, strike, "PE")
    if ce is None or pe is None:
        print("Paper: cannot find ATM CE/PE rows for strike", strike)
        return None, None
    call_trade = paper_sell_option_leg(ce, "CALL", LOT_SIZE)
    put_trade = paper_sell_option_leg(pe, "PUT", LOT_SIZE)
    state["straddle"] = {"call_row": ce, "put_row": pe, "strike": strike, "placed_at": datetime.now().isoformat()}
    state["trades_today"] += 1
    send_telegram(f"[PAPER] Short straddle simulated at strike {strike}: CALL@{call_trade['entry_price']}, PUT@{put_trade['entry_price']}")
    # capture IV snapshot if available
    call_iv = safe_get_field(ce, ["iv", "implied_volatility", "impliedVol"])
    put_iv = safe_get_field(pe, ["iv", "implied_volatility", "impliedVol"])
    try:
        if call_iv is not None and put_iv is not None:
            state["initial_iv"] = (float(call_iv) + float(put_iv)) / 2.0
            state["last_iv"] = state["initial_iv"]
    except Exception:
        pass
    return call_trade, put_trade

def paper_exit_all(reason: str = "EOD"):
    """Close all open paper shorts at LTPs (simulated)."""
    df = fetch_option_chain(state.get("under_security_id")) if state.get("under_security_id") else pd.DataFrame()
    for t in list(state["paper_positions"]):
        if t.get("closed"):
            continue
        sec_row = None
        try:
            if not df.empty and "security_id" in df.columns:
                sec_row = df[df["security_id"].astype(str) == str(t["security"])]
                if not sec_row.empty:
                    sec_row = sec_row.iloc[0]
                else:
                    sec_row = None
        except Exception:
            sec_row = None
        # fallback: use stored rows in state['straddle']
        if sec_row is None and state.get("straddle"):
            sec_row = state["straddle"]["call_row"] if t["leg"] == "CALL" else state["straddle"]["put_row"]
        paper_buy_to_close(sec_row, t["leg"], t["qty"])
    send_telegram(f"[PAPER EXIT] All simulated positions closed ({reason}). Daily P/L: {state['daily_pl']:+.2f}")
    # reset straddle state
    state["straddle"] = None
    state["paper_positions"] = []

# ----------------------------- GREEKS & IV -----------------------------
def compute_net_greeks_and_iv_paper() -> Tuple[float, float, Optional[float]]:
    """Return net_delta, net_theta, avg_iv for the simulated straddle (paper)."""
    s = state.get("straddle")
    if not s:
        return 0.0, 0.0, None
    call_row = s.get("call_row")
    put_row = s.get("put_row")
    call_delta = safe_get_field(call_row, ["delta", "greeks.delta", "greek_delta"]) or 0.0
    put_delta = safe_get_field(put_row, ["delta", "greeks.delta", "greek_delta"]) or 0.0
    call_theta = safe_get_field(call_row, ["theta", "greeks.theta", "greek_theta"]) or 0.0
    put_theta = safe_get_field(put_row, ["theta", "greeks.theta", "greek_theta"]) or 0.0
    call_iv = safe_get_field(call_row, ["iv", "implied_volatility", "impliedVol"])
    put_iv = safe_get_field(put_row, ["iv", "implied_volatility", "impliedVol"])
    try:
        call_delta = float(call_delta); put_delta = float(put_delta)
    except Exception:
        call_delta = 0.0; put_delta = 0.0
    try:
        call_theta = float(call_theta); put_theta = float(put_theta)
    except Exception:
        call_theta = 0.0; put_theta = 0.0
    ivs = []
    for v in (call_iv, put_iv):
        try:
            if v is not None:
                ivs.append(float(v))
        except Exception:
            pass
    avg_iv = sum(ivs) / len(ivs) if ivs else None
    net_delta = -(call_delta * LOT_SIZE) - (put_delta * LOT_SIZE)
    net_theta = -(call_theta * LOT_SIZE) - (put_theta * LOT_SIZE)
    return float(net_delta), float(net_theta), (float(avg_iv) if avg_iv is not None else None)

# ----------------------------- IV SPIKE (PAPER ACTIONS) -----------------------------
def paper_check_iv_spike_and_take_action(avg_iv: Optional[float]):
    """Use initial_iv as baseline; if avg_iv rises beyond thresholds -> pause / alert."""
    if avg_iv is None:
        return
    if state.get("initial_iv") is None:
        state["initial_iv"] = avg_iv
        state["last_iv"] = avg_iv
        return
    initial = state["initial_iv"]
    pct = (avg_iv - initial) / initial if initial and initial != 0 else 0.0
    state["last_iv"] = avg_iv
    if pct >= VIX_SPIKE_PCT_1 and not state.get("trading_paused"):
        state["trading_paused"] = True
        state["paused_reason"] = f"IV +{pct*100:.2f}%"
        send_telegram(f"[PAPER] IV spike simulated: avg_iv {avg_iv:.3f} (+{pct*100:.2f}%) -> Pausing new trades")
    if pct >= VIX_SPIKE_PCT_2:
        send_telegram("[PAPER] IV strong spike -> suggest hedging (paper only)")
    if pct >= VIX_SPIKE_PCT_3:
        send_telegram("[PAPER] IV extreme spike -> consider closing positions (paper)")

# ----------------------------- CSV LOGGING -----------------------------
def log_paper_trade(rec: dict, action: str = "ENTRY"):
    """Append paper trade/exit to CSV for analysis."""
    row = {
        "timestamp": datetime.now().isoformat(),
        "action": action,
        **rec
    }
    # ensure consistent header on first write
    write_header = False
    try:
        # check if file exists
        with open(TRADE_LOG_CSV, "r"):
            pass
    except Exception:
        write_header = True

    try:
        with open(TRADE_LOG_CSV, "a", newline="") as f:
            writer = csv.DictWriter(f, fieldnames=list(row.keys()))
            if write_header:
                writer.writeheader()
            writer.writerow(row)
    except Exception as e:
        print("log_paper_trade error:", e)

# ----------------------------- DAILY RESET -----------------------------
def reset_daily_if_needed():
    now = datetime.now()
    if state.get("last_reset_date") != now.date():
        state["theta_alert_sent_today"] = False
        state["trades_today"] = 0
        state["daily_pl"] = 0.0
        state["trading_paused"] = False
        state["paused_reason"] = None
        state["last_reset_date"] = now.date()

# ----------------------------- MAIN PAPER LOOP -----------------------------
def paper_main_loop(run_minutes: Optional[int] = None):
    send_telegram("[PAPER] Bot starting (paper mode).")
    started = datetime.now()
    while True:
        try:
            reset_daily_if_needed()

            wd = today_weekday()
            key = WEEK_RULES.get(wd)
            if key is None:
                # no trade day (Friday or weekend)
                print(f"No trading today ({datetime.now().strftime('%A')}). Sleeping 60s.")
                time.sleep(60)
                continue

            under_info = UNDERLYINGS.get(key)
            under_id = under_info["under_security_id"]
            state["under_security_id"] = under_id

            # if paused due to IV spike, we still monitor and hedge suggestions
            if state.get("trading_paused"):
                print("Paper mode: trading paused due to:", state.get("paused_reason"))
                if state.get("straddle"):
                    net_delta, net_theta, avg_iv = compute_net_greeks_and_iv_paper()
                    paper_check_iv_spike_and_take_action(avg_iv)
                time.sleep(POLL_INTERVAL)
                continue

            # ENTRY window
            if in_time_window(ENTRY_WINDOW_START, ENTRY_WINDOW_END) and state["trades_today"] < MAX_TRADES_PER_DAY and state.get("straddle") is None:
                if in_time_window(NO_TRADE_START, NO_TRADE_END):
                    print("Inside early volatility zone; skipping entry.")
                else:
                    strike = atm_from_api(key)
                    if strike is None:
                        print("Paper: cannot determine ATM. retrying.")
                    else:
                        paper_place_short_straddle(under_id, strike)

            # Monitoring after entry
            if state.get("straddle"):
                net_delta, net_theta, avg_iv = compute_net_greeks_and_iv_paper()
                print(f"[PAPER MON] NetDelta {net_delta:.3f} | NetTheta {net_theta:.3f} | AvgIV {avg_iv}")
                # IV spike checks
                paper_check_iv_spike_and_take_action(avg_iv)

                # Auto SHIFT (simulate)
                if abs(net_delta) >= DELTA_SHIFT_THRESHOLD:
                    side = "call" if net_delta > 0 else "put"
                    send_telegram(f"[PAPER] Delta one-sided {net_delta:.3f} -> simulate shifting {side}")
                    s = state["straddle"]
                    df = fetch_option_chain(under_id)
                    if side == "call":
                        paper_buy_to_close(s["call_row"], "CALL", LOT_SIZE)
                        new_strike = s["strike"] + STRIKE_STEP * 2
                        new_call = find_option_by_strike_and_type(df, new_strike, "CE")
                        if new_call is not None:
                            paper_sell_option_leg(new_call, "CALL", LOT_SIZE)
                            send_telegram(f"[PAPER] Shifted CALL to strike {new_strike}")
                        else:
                            send_telegram("[PAPER] Shift skip: new CE not found")
                    else:
                        paper_buy_to_close(s["put_row"], "PUT", LOT_SIZE)
                        new_strike = s["strike"] - STRIKE_STEP * 2
                        new_put = find_option_by_strike_and_type(df, new_strike, "PE")
                        if new_put is not None:
                            paper_sell_option_leg(new_put, "PUT", LOT_SIZE)
                            send_telegram(f"[PAPER] Shifted PUT to strike {new_strike}")
                        else:
                            send_telegram("[PAPER] Shift skip: new PE not found")

                # Partial exit near PARTIAL_EXIT_TIME: close half
                if in_time_window(PARTIAL_EXIT_TIME, (datetime.combine(datetime.today(), PARTIAL_EXIT_TIME) + timedelta(minutes=15)).time()):
                    send_telegram("[PAPER] Partial exit window -> simulate reducing exposure by 50%")
                    s = state.get("straddle")
                    if s:
                        paper_buy_to_close(s["call_row"], "CALL", int(LOT_SIZE / 2))
                        paper_buy_to_close(s["put_row"], "PUT", int(LOT_SIZE / 2))

                # Full exit at or after FULL_EXIT_TIME
                if now_time() >= FULL_EXIT_TIME:
                    send_telegram("[PAPER] Full exit time reached -> closing all paper positions")
                    paper_exit_all(reason="FULL_EXIT_TIME")

            # Enforce daily profit/loss caps (paper-level alerts)
            if state["daily_pl"] >= DAILY_PROFIT_LIMIT:
                send_telegram(f"[PAPER] Daily profit limit reached {state['daily_pl']:.2f} -> stopping paper entries")
                state["trading_paused"] = True
            if state["daily_pl"] <= DAILY_LOSS_LIMIT:
                send_telegram(f"[PAPER] Daily loss limit breached {state['daily_pl']:.2f} -> stopping paper entries")
                state["trading_paused"] = True

            # termination by minutes if requested (useful for tests)
            if run_minutes is not None and (datetime.now() - started).total_seconds() >= run_minutes * 60:
                print("Run minutes elapsed -> stopping paper loop")
                break

            time.sleep(POLL_INTERVAL)

        except KeyboardInterrupt:
            print("Paper run stopped by user")
            break
        except Exception as exc:
            print("Paper loop error:", exc)
            time.sleep(5)

if __name__ == "__main__":
    # run_minutes can be set to an int for quick tests (minutes), or None to run indefinitely
    paper_main_loop(run_minutes=None)
